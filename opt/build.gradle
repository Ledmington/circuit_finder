plugins {
	id 'java-library'
	id 'com.diffplug.spotless' version '6.22.0'
	id 'com.github.ben-manes.versions' version '0.49.0'
	id 'com.adarshr.test-logger' version '4.0.0'
	id 'info.solidsoft.pitest' version '1.15.0'
	id 'me.champeau.jmh' version '0.7.2'
}

repositories {
	mavenCentral()
}

static def path(String... args) {
	return String.join(File.separator, args)
}

String appName = 'circuit-finder'
String version = '0.1.0'
String appDescription = 'A search algorithm to find optimal logic circuits.'
String author = 'Filippo Barbari'
String authorMail = 'filippo.barbari@gmail.com'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

ext.junitVersion = "5.10.0"
dependencies {
	implementation project(':utils')
	testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
	testImplementation "org.junit.jupiter:junit-jupiter-params:${junitVersion}"
	testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
	testRuntimeOnly('org.junit.platform:junit-platform-launcher:1.10.0') {
		because("required for pitest")
	}
}

test {
	useJUnitPlatform()
}

testlogger {
	theme 'standard'

	showExceptions true
	showStackTraces false
	showFullStackTraces true
	showCauses true

	slowThreshold 2000

	showSummary true
	showSimpleNames false
	showPassed false
	showSkipped true
	showFailed true
	showOnlySlow false

	showStandardStreams true
	showPassedStandardStreams false
	showSkippedStandardStreams false
	showFailedStandardStreams true
}

pitest {
	targetClasses.set(['com.ledmington.*'])
	targetTests.set(['com.ledmington.*'])
	pitestVersion = '1.15.0' //not needed when a default PIT version should be used
	junit5PluginVersion = '1.2.0'
	threads = 4
	outputFormats.set(['HTML'])
	verbose = true
	timestampedReports = false
}

tasks.withType(JavaCompile).configureEach {
	options.compilerArgs << '-Xdiags:verbose'
	options.compilerArgs << '-Xlint:all'
	options.compilerArgs << '-Werror'
	options.deprecation = true
	options.encoding = 'UTF-8'
}

spotless {
	format 'misc', {
		target '*.gradle', '*.md', '.gitignore'
		trimTrailingWhitespace()
		indentWithTabs()
		endWithNewline()
		setEncoding('utf-8')
	}

	java {
		target fileTree('.') {
			include path('**', '*.java')
			exclude path('**', 'build', '**'), path('**', 'build-*', '**'), path('**', 'bin', '**')
		}
		removeUnusedImports()
		formatAnnotations()
		trimTrailingWhitespace()
		endWithNewline()
		setEncoding('utf-8')
		palantirJavaFormat('2.38.0')

		// check https://javadoc.io/doc/com.diffplug.spotless/spotless-plugin-gradle/latest/com/diffplug/gradle/spotless/JavaExtension.html
		importOrder('java', 'javax', 'javafx', 'com', 'org', group as String)

		licenseHeader String.join("\n", "/*",
				" * Copyright (C) 2023-${new Date().format('yyyy')} ${author} <${authorMail}>",
				" *",
				" * This file is part of ${appName}.",
				" *",
				" * ${appName} can not be copied and/or distributed without",
				" * the explicit permission of ${author}.",
				" */")
	}
}

tasks.compileJava.dependsOn(spotlessApply)

jmh {
	//includes = ['some regular expression'] // include pattern (regular expression) for benchmarks to be executed
	//excludes = ['some regular expression'] // exclude pattern (regular expression) for benchmarks to be executed
	iterations = 10 // Number of measurement iterations to do.
	//benchmarkMode = ['thrpt','ss'] // Benchmark mode. Available modes are: [Throughput/thrpt, AverageTime/avgt, SampleTime/sample, SingleShotTime/ss, All/all]
	//batchSize = 1 // Batch size: number of benchmark method calls per operation. (some benchmark modes can ignore this setting)
	fork = 2 // How many times to forks a single benchmark. Use 0 to disable forking altogether
	failOnError = true // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?
	forceGC = false // Should JMH force GC between iterations?
	//jvm = 'myjvm' // Custom JVM to use when forking.
	//jvmArgs = ['Custom JVM args to use when forking.']
	//jvmArgsAppend = ['Custom JVM args to use when forking (append these)']
	//jvmArgsPrepend =[ 'Custom JVM args to use when forking (prepend these)']
	//humanOutputFile = project.file("${project.buildDir}/reports/jmh/human.txt") // human-readable output file
	resultsFile = project.file("${project.buildDir}/reports/jmh/results.txt") // results file
	//operationsPerInvocation = 10 // Operations per invocation.
	//benchmarkParameters =  [:] // Benchmark parameters.
	//profilers = [] // Use profilers to collect additional data. Supported profilers: [cl, comp, gc, stack, perf, perfnorm, perfasm, xperf, xperfasm, hs_cl, hs_comp, hs_gc, hs_rt, hs_thr, async]
	//timeOnIteration = '1s' // Time to spend at each measurement iteration.
	resultFormat = 'TEXT' // Result format type (one of CSV, JSON, NONE, SCSV, TEXT)
	//synchronizeIterations = true // Synchronize iterations?
	threads = 1 // Number of worker threads to run with.
	//threadGroups = [2,3,4] //Override thread group distribution for asymmetric benchmarks.
	//jmhTimeout = '1s' // Timeout for benchmark iteration.
	//timeUnit = 'ms' // Output time unit. Available time units are: [m, s, ms, us, ns].
	verbosity = 'EXTRA' // Verbosity mode. Available modes are: [SILENT, NORMAL, EXTRA]
	//warmup = '1s' // Time to spend at each warmup iteration.
	//warmupBatchSize = 10 // Warmup batch size: number of benchmark method calls per operation.
	//warmupForks = 0 // How many warmup forks to make for a single benchmark. 0 to disable warmup forks.
	//warmupIterations = 1 // Number of warmup iterations to do.
	//warmupMode = 'INDI' // Warmup mode for warming up selected benchmarks. Warmup modes are: [INDI, BULK, BULK_INDI].
	//warmupBenchmarks = ['.*Warmup'] // Warmup benchmarks to include in the run in addition to already selected. JMH will not measure these benchmarks, but only use them for the warmup.

	zip64 = true // Use ZIP64 format for bigger archives
	jmhVersion = '1.37' // Specifies JMH version
	//includeTests = true // Allows to include test sources into generate JMH jar, i.e. use it when benchmarks depend on the test classes.
	//duplicateClassesStrategy = DuplicatesStrategy.FAIL // Strategy to apply when encountering duplicate classes during creation of the fat jar (i.e. while executing jmhJar task)
}
